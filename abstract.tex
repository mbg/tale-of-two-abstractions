%We present an encoding of the principal features of object-oriented languages in pure Haskell. Our system supports object classes, inheritance, subtype polymorphism, dynamic dispatch, and open recursion. We establish a correspondence between inheritance and monad transformers by defining a state monad transformer for each class, parametrised only over the class's own state. The methods of a class are monadic computations which run on top of a stack of monad transformers, consisting of one layer for the class and each of its ancestors. Well-known limitations of monad transformers are overcome by the dynamic dispatch mechanism. The encoding allows class hierarchies to be open for extension in separately-compiled modules, therefore allowing the construction of modular programs. We show how to translate to our encoding from a small object-oriented language. Finally, we provide a Template Haskell implementation of this translation.

%Monad transformers are infamous for being awkward to work with. By only considering state monad transformers, we show that there exists a correspondence to the usual inheritance mechanism of object-oriented languages. While such languages take care of the boilerplate required for inheritance to work seamlessly, this is not the case for monad transformers. We exploit this correspondence and combine state monad transformers with the principal features of object-oriented languages, allowing us to treat stacks of state monad transformers like objects. We illustrate using examples that these objects are as easy to work with as their counterparts in object-oriented languages. Additionally, if we extend our system with an encoding for subtyping, we are able to write modular programs. Our system is encoded entirely in Haskell and requires no new language features. A Template Haskell library allows programmers to write class definitions in the same style as in object-oriented languages which then get translated to the corresponding encodings. We hope that our findings will form the foundation for a generalised system in which classes can have effects other than state.


Monad transformers are infamous for being awkward to work with. To begin tackling this problem, we formulate a correspondence between state monad transformers and the inheritance mechanism of object-oriented languages. While object-oriented languages implicitly supply the boilerplate required for inheritance to work seamlessly, state monad transformers require it to be explicit. By hiding this boilerplate in type class instances, we simulate the dispatch mechanisms of object-oriented languages. This allows us to use stacks of state monad transformers as easily as objects. We illustrate using examples that these `objects' are as easy to work with as their object-oriented counterparts.

Our `object classes' do not need to know about other `object classes' which inherit from them. The resulting hierarchy is therefore open for extension. This can be taken advantage of to construct modular data types and programs through the addition of an encoding for subtyping. All of this is encoded entirely in Haskell and requires no new language features. Finally, a Template Haskell library allows programmers to write class definitions in the same style as in object-oriented languages from which the boilerplate can automatically be derived.



%This opens up an exciting new 
%By establishing the effect of monad transformers to be a generalised form of inheritance, we show that state monad transformers can be used as natural interpreters for an object-oriented language. 

