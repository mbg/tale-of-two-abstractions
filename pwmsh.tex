
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage{xcolor}
\newcommand{\todo}[1]{[{\color{blue}#1}]}

\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Object-Oriented Programming with\\Monadic State Hierarchies}

% a short form should be given in case it is too long for the running head
%\titlerunning{Programming with monadic state hierarchies}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Michael B. Gale \and Alan Mycroft}
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Computer Laboratory, University of Cambridge}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
We present an encoding of an object system in pure Haskell which supports most conventional features of object-oriented languages, including object classes, inheritance, subtype polymorphism, and dynamic dispatch. We show a correspondence between inheritance and monad transformers by defining a state monad transformer for each class, parametrised only over the class's own state. The methods of a class are monadic computations which run on top of a stack of monad transformers, consisting of one layer for the class and each of its ancestors. The well-known limitation that functions must be ``lifted'' into the right place within a monad stack is overcome using dynamic dispatch. This encoding allows class hierarchies to be open for extension in separately-compiled modules, therefore allowing the construction of modular programs. 

\keywords{Haskell, Monad Transformers, Object-Oriented Programming}
\end{abstract}


\section{Introduction}
\label{sec:introduction}

\todo{Alan: may be confusing for referees with backgrounds in either OO or FUN}
\todo{Should there be some form of introduction to monads -- in particularly the state monad? Maybe a reference to a good paper?}

It is folklore that dynamic dispatch can be implemented in Haskell with existential types and type classes. In the following example, a value of type $\mathit{Bird}$ is constructed by applying the $\mathit{MkBird}$ constructor to some type $a$ for which there is an instance of the $\mathit{BirdLike}$ type class:
\begin{displaymath}
\begin{array}{lcl}
\mathbf{data}~\mathit{Bird} & = & \forall a. \mathit{BirdLike}~a \Rightarrow \mathit{MkBird}~a
\end{array}
\end{displaymath}
The $\mathit{Bird}$ type effectively serves as an abstract base class. It is not possible to obtain a value of this type without some other type $a$ which implements $\mathit{BirdLike}$. Any such type can be seen as a subtype of $\mathit{Bird}$ and type-casts to the base class are possible by applying the $\mathit{MkBird}$ constructor. The type class constraint ensures that every subtype has the properties we would expect of, in this example, a bird.

This is an intriguing concept, but is often perceived as an anti-pattern \todo{cite?}. After all, why should we bother with a base class type if we can simply place a type class constraint on every function expecting bird-like arguments and avoid the $\mathit{Bird}$ type all-together?

We answer this question and show how the above concept can be elevated from a neat trick without much practical use to the foundation of an object system for purely-functional languages with a range of benefits \todo{``range of''?}. Specifically, our contributions are:
\begin{itemize}
\item We build upon the technique of using existential types combined with type classes to encode a comprehensive object system in Haskell, supporting object classes, inheritance, subtype polymorphism, and non-aliased mutation \todo{adjust this list?}. In Section \ref{sec:usage} we first show how objects in our encoding are used within a standard Haskell program, before describing the encoding itself in Section \ref{sec:encoding}.
\item Class hierarchies in our encoding are open for extension in separately-compiled modules. We thereby improve upon \emph{e.g.} open data types and functions\cite{loh2006open} which require whole program compilation.
\item \todo{Alan: monad stacks?}Monad transformers are infamous \todo{cite?} for requiring programmers to explicitly reference where in a stack of monad transformers a function should be executed. In Haskell, this is accomplished by wrapping a function in a call to $\mathit{lift}$ for every monad in the stack that should be skipped. Our system hides this boilerplate in the dynamic dispatch mechanism. 
\item In Section \ref{sec:auto}, we show a simple notation for object classes, following the conventions of object-oriented languages, that can be used by a pre-processor to generate the corresponding encodings in Haskell.
\end{itemize}

\section{Using the Encoding}
\label{sec:usage}

Before diving into the mechanics of our encoding, let us consider a couple of \todo{adjust} examples in the notation which we introduce in detail in Section \ref{sec:auto}. We begin with an implementation of OO-style linked lists, for which we define a class of list items containing values of some type $a$:
\begin{displaymath}
\begin{array}{l}
\mathbf{state}~\mathit{MListItem}~a~\mathbf{where} \\
\quad \begin{array}{lcl}
\mathbf{data}~\mathit{value} & :: & a \\
\mathbf{data}~\mathit{next}  & :: & \mathit{Maybe}~(\mathit{MListItem}~a)
\end{array}\\\\
\quad \begin{array}{lcl}
\mathit{insertTo} & :: & \mathit{MListItem}~a \to ()\\
\mathit{insertTo}~v & = & \mathbf{do} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{mn} & <: & \mathit{next} \\
\multicolumn{3}{l}{\mathbf{case}~\mathit{mn}~\mathbf{of}} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{Nothing} & \to & \mathbf{do}~\mathit{Just}~v >: \mathit{next} \\
(\mathit{Just}~n) & \to & \mathbf{do}~\mathit{Just}~(\mathit{snd}~\$~n.\mathit{insertTo}~v) >: \mathit{next}
\end{array}}
\end{array}}
\end{array}
\end{array}
\end{displaymath}
This declaration introduces a new object class $\mathit{MListItem}$ with two fields, $\mathit{value}$ and $\mathit{next}$, as well as one method named $\mathit{insertTo}$. Note that the explicit typing for this method gives it a pure type, despite having the effect of transforming an object's state. The reason for this design choice is twofold: the effectful type can be inferred from the context in which the method is defined and the corresponding monad is not given a name until we desugar the class definition. % The type of this method may initially seem confusing since we would expect it to return an updated object and the $\mathbf{do}$-notation suggests a monad. This is indeed the case, but since all methods are automatically state transformers belonging to a state monad

Our notation also extends Haskell's $\mathbf{do}$ notation with two new forms of statements. A $\mathit{pattern} <: \mathit{name}$ statement retrieves the current value of the field whose name is given by $\mathit{name}$ and binds it to $\mathit{pattern}$. Conversely, a $\mathit{expr} >: \mathit{name}$ statement sets the value of the $\mathit{name}$ field to that of $\mathit{expr}$.

$n.\mathit{insertTo}$ invokes the $\mathit{insertTo}$ method on $n$.

For convenience, we define a function to serve as a smart constructor for new $\mathit{MListItem}$ objects below. The $\mathbf{new}$ keyword, followed by the name of an object class, is used to construct the internal structure of the object:
\begin{displaymath}
\begin{array}{lcl}
\mathit{mkItem} & :: & a \to \mathit{MListItem}~a \\
\mathit{mkItem}~v & = & \mathbf{new}~\mathit{MListItem}~v~\mathit{Nothing}
\end{array}
\end{displaymath}

By setting the $\mathit{next}$ field of a $\mathit{MListItem}$ object to a value other than $\mathit{Nothing}$, elements can be added to the list. A value of $\mathit{Nothing}$ indicates the end of the list. To account for the empty list, we declare a $\mathit{MutableList}$ class which we use as the start of a linked list:
\begin{displaymath}
\begin{array}{l}
\mathbf{state}~\mathit{MList}~a~\mathbf{where} \\
\quad \begin{array}{lcl}
\mathbf{data}~\mathit{root}  & :: & \mathit{Maybe}~(\mathit{MListItem}~a)
\end{array}\\\\
\quad \begin{array}{lcl}
\mathit{insert} & :: & a \to () \\
%\mathit{insert}~v & = & \mathbf{do} \\
%\multicolumn{3}{l}{\quad \begin{array}{lcl}
%\multicolumn{3}{l}{\mathbf{let}}\\
%\multicolumn{3}{l}{\quad \mathit{item} = \mathit{mkItem}~v} \\
%\mathit{mr} & <: & \mathit{root} \\
%\multicolumn{3}{l}{\mathbf{case}~\mathit{mr}~\mathbf{of}} \\
%\multicolumn{3}{l}{\quad \begin{array}{lcl}
%\mathit{Nothing} & \to & \mathbf{do}~\mathit{Just}~\mathit{item} >: \mathit{root} \\
%(\mathit{Just}~r) & \to & \mathbf{do}~\mathit{Just}~(\mathit{snd}~\$~r.\mathit{insertTo}~\mathit{item}) >: \mathit{root}
%\end{array}}
%\end{array}}
\mathit{toList} & :: & [a]
\end{array}
\end{array}
\end{displaymath}
We omit the definitions of the $\mathit{insert}$ and $\mathit{toList}$ methods as they follow similar structures as the $\mathit{insertTo}$ method of the $\mathit{MListItem}$ class. The $\mathit{mkItem}$ function can be used to turn the value to insert into a $\mathit{MListItem}$ object. To test our construction, we define a function that, given an OO-style list of integers, inserts a few integers, and finally converts it to a functional list:
\begin{displaymath}
\begin{array}{lcl}
\mathit{test} & :: & \mathit{MList}~\mathit{Int} \to [\mathit{Int}]\\
\mathit{test}~l & = & \mathbf{let} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
a & = & \mathit{snd}~\$~l.\mathit{insert}~23\\
b & = & \mathit{snd}~\$~l.\mathit{insert}~16\\
c & = & \mathit{snd}~\$~l.\mathit{insert}~42\\
d & = & \mathit{snd}~\$~l.\mathit{insert}~24\\
\end{array}}\\
\multicolumn{3}{l}{\mathbf{in}~\mathit{fst}~\$~d.\mathit{toList}}
\end{array}
\end{displaymath}
%Note that we assume that the $\mathit{MList}$ class has been extended with a $\mathit{toList}$ function which traverses the OO-style list and returns a corresponding functional list. 
Applying $\mathit{test}$ to an empty list results in the following reduction:
\begin{displaymath}
\begin{array}{cl}
 & \mathit{test}~(\mathbf{new}~\mathit{MList}~\mathit{Nothing}) \\
\Rightarrow & [23,16,42,24]
\end{array}
\end{displaymath}
Now suppose that we wish to define a class of lists which are always sorted according to some predicate. Instead of starting from scratch, we define a class $\mathit{SList}$ which derives from $\mathit{MList}$. This is indicated using a notation borrowed from C++:

\begin{displaymath}
\begin{array}{l}
\mathbf{state}~\mathit{SList}~a : \mathit{MList}~a~\mathbf{where} \\
\quad \begin{array}{lcl}
\mathbf{data}~\mathit{pred}  & :: & a \to a \to \mathit{Bool}
\end{array}\\\\
\quad \begin{array}{lcl}
\mathit{insert} & :: & a \to ()\\
\mathit{insert}~v & = & \mathbf{do} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\multicolumn{3}{l}{\mathbf{let}}\\
\multicolumn{3}{l}{\quad \mathit{item} = \mathit{mkItem}~v} \\
\mathit{mr} & <: & \mathit{root} \\
\multicolumn{3}{l}{\mathbf{case}~\mathit{mr}~\mathbf{of}} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{Nothing} & \to & \mathbf{do}~(\mathit{Just}~\mathit{item}) >: \mathit{root} \\
(\mathit{Just}~r) & \to & \mathbf{do} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
p & <: & \mathit{pred} \\
\mathit{Just}~(\mathit{helper}~v~p~r) & >: & \mathit{root}
\end{array}}
\end{array}}
\end{array}}
\end{array}
\end{array}
\end{displaymath}
By deriving $\mathit{SList}$ from $\mathit{MList}$, it has inherited all fields and methods of its parent. Additionally, we have added a $\mathit{pred}$ field used to store the predicate according to which the list should be sorted. We have also overriden the definition of $\mathit{insert}$ to use the $\mathit{helper}$ function whose definition is given below to insert a new item at the correct position within the list:
\begin{displaymath}
\begin{array}{lcl}
\multicolumn{3}{l}{\mathit{helper} :: a \to (a \to a \to \mathit{Bool}) \to \mathit{MutableListItem}~a \to \mathit{MutableListItem}~a} \\
\mathit{helper}~v~p~i & = & \mathbf{let} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{rv} & = & c.\mathit{getValue} \\
\mathit{item} & = & \mathit{mkItem}~v
\end{array}}\\
\multicolumn{3}{l}{\quad \mathbf{in}~\mathbf{if}~v~`p`~rv~\mathbf{then}~\mathbf{case}~c.\mathit{getNext}~\mathbf{of}} \\
\multicolumn{3}{l}{\quad \quad \begin{array}{lcl}
\mathit{Nothing} & \to & c.\mathit{setNext}~\$~\mathit{Just}~\mathit{item} \\
(\mathit{Just}~n) & \to & c.\mathit{setNext}~\$~\mathit{Just}~\$~\mathit{helper}~v~p~n 
\end{array}} \\
\multicolumn{3}{l}{\quad \mathbf{else}~\mathit{item}.\mathit{setNext}~(\mathit{Just}~c)}
\end{array}
\end{displaymath}
Applying the $\mathit{test}$ function we defined earlier to an $\mathit{SList}$ object directly is not possible. In other words, even though we consider $\mathit{SList}$ to be a subtype of $\mathit{MList}$, an explicit cast must be inserted in the form of a $\mathit{downcast}$ function:
\begin{displaymath}
\begin{array}{cl}
 & \mathit{test}~(downcast~\$~\mathbf{new}~\mathit{SList}~\mathit{Nothing}~(>)) \\
\Rightarrow & [16,23,24,42]
\end{array}
\end{displaymath}   
Evaluating this expression results in a sorted list. \todo{benefits, biggest potential criticism: a lot of complexity for little (obvious) programming gain}

\section{Encoding}
\label{sec:encoding}

\todo{The gory details}

\begin{itemize}
\item Three types per object class: data, object, and state monad
\item Different ``zipper'' arrangements depending on base/child, abstract, and final attributes
\item Type class per object class with 2 functions for each method (external vs. internal call)
\item Zipper traversal in the function definitions and construction of the monad stack
\end{itemize}

Encoding an object class in standard Haskell yields several components. Firstly, we define a single-constructor data type to represent the state of an object. For example, for the $\mathit{SList}$ class, we have the following:
\begin{displaymath}
\begin{array}{lcl}
\mathbf{data}~\mathit{SListState}~a & = & \mathit{MkSListState}~\{~ \_ slist \_ pred :: a \to a \to \mathit{Bool}~\}
\end{array}
\end{displaymath}
Note that this does not include any state inherited from the $\mathit{MList}$ class.




\includegraphics{images/figures-figure0.eps}

\begin{displaymath}
\begin{array}{lcl}
\mathbf{data}~\mathit{MutableListState}~a & = & \mathit{MkMutableListState}~\{  \} \\
\mathbf{data}~\mathit{MutableListObject}~a & = & \\
 & \mid & \forall s~d\\
\mathbf{type}~\mathit{MutableList}~a & = & \mathit{StateT}~()~\mathit{Identity}
\end{array}
\end{displaymath}

\begin{displaymath}
\begin{array}{l}
\mathbf{class}~\mathit{Monad}~m \Rightarrow \mathit{MutableListLike}~e~s~m~a \mid e \to s, s \to e~\mathbf{where} \\
\quad \begin{array}{lcl}
\mathit{\textunderscore get \textunderscore list \textunderscore root} & :: & e~a \to m~(\mathit{Maybe}~(\mathit{MutableListItemObject~a}),e~a) \\
\mathit{insert} & :: & e~a \to a \to m~((),e~a) \\
\mathit{insert}' & :: & a \to \mathit{StateT}~(s~a)~m~()
\end{array}
\end{array}
\end{displaymath}

\begin{figure}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline  & Base & Abstract & Final \\ 
\hline zipper alignment &  &  &  \\ 
\hline  &  &  &  \\ 
\hline  &  &  &  \\ 
\hline  &  &  &  \\ 
\hline 
\end{tabular} 
\end{center}

\caption{Object constructors}\label{tab:constructors}
\end{figure}

\section{Casts}
\label{sec:casts}

We have shown that calling a method on an object sets up a stack of state monad transformers parametrised over each $\delta$-object's state. This is straight-forward if the object

So far we have shown how to call methods on base class objects, but since subtyping is represented on the value as well as the type level, we require some additional 

\begin{itemize}
\item internal $\mathit{invoke}$ function which uses the zipper to construct a monad stack from an arbitrary focus
\end{itemize}

\section{Auto-generation}
\label{sec:auto}

\begin{itemize}
\item translation rules for notation to standard Haskell
\end{itemize}

\section{Related Work}
\label{sec:related}

\begin{itemize}
\item Haskell's hidden object system
\item open data types and open functions
\item data types a la carte
\item extensible effects, etc.
\end{itemize}

\todo{Relevant parts from my thesis proposal:}

\cite{jaskelioff2011monatron} shows a monad transformer library called \emph{Monatron} which features an improved lifting mechanism at the cost of increased implementation complexity. \cite{schrijvers2011monads} describe \emph{monad zippers} and \emph{monad views} which are used to hide and address parts of monad stacks, respectively.

The most promising solution so far has been presented in \cite{kiselyov2013extensible} where a single monad, parameterised over a set of effect handlers \cite{plotkin2009handlers} is used to effectively implement an effect system in Haskell. The order of effects is not fixed on the type-level, but is determined on the value level. This system is also more efficient than monad transformers since it is no longer necessary to call each monad's $\gg\!\!=$ function at every step. 

%\section{Effect handlers}

%Effect handlers \citep{plotkin2009handlers}, etc.

Extending Haskell with an object system is not a new idea. \cite{OOHaskell} present such an encoding, but focus on remaining true to object-oriented programming. As a result, their system is impure and requires IO references to account for mutability and aliasing. \cite{shields2001object} show how to extend Haskell to allow the encoding of object-oriented style overloading. Their goal is to allow Haskell programs to provide interfaces to libraries written in object-oriented languages, but not to write object-oriented style code in Haskell itself.

In more theoretical work, \cite{Pierce93simpletype-theoretic} present a typed $\lambda$-calculus with support for encapsulation, message passing, subtyping, and inheritance. Methods in this calculus are state transformers, but they do not form stacks of state monad transformers. Instead, methods simply use the object as state as in traditional object-oriented programming.

The expression problem \cite{wadler1998expression} is concerned with extending programs with new functionality without having to change any of the existing code. A classical example of this is wishing to extend an expression language which supports basic arithmetic expressions with new forms of expressions which add \emph{e.g.} support for exceptions.  

In object-oriented programming languages this can be accomplished using an abstract class for expressions which all forms of expressions derive from. Our system allows for similar implementations. However, other approaches exist for Haskell. \cite{loh2006open} propose an extension to Haskell which enables data types and functions to be marked as ``open'', allowing new constructors and equations to be added respectively after an initial declaration. This is accomplished by generating normal data types and functions from all open declarations within a program. Unfortunately, their proposal also requires the order in which pattern matching occurs to be changed.

\cite{swierstra2008data} shows how modular data types can be constructed without any new extensions to Haskell's type system. This approach has been used to construct \emph{e.g.} modular compilers \cite{day2012towards}, but is more complicated than open data types are. 

\section{Conclusion and Future Work}
\label{sec:conclusions}

\begin{itemize}
\item extend to other monad transformers / effects to avoid the ``lifting''
\item exploit additional structure for more efficient compilation 
\item aliasing 
\end{itemize}

\subsubsection*{Acknowledgments.} Content

\begin{thebibliography}{4}

\bibitem{day2012towards}
Day, Laurence~E. \& Hutton, Graham.
\newblock Towards modular compilers for effects.
\newblock In \emph{Trends in Functional Programming}, pages 49--64. Springer,
  2012.

\bibitem{jaskelioff2011monatron}
Jaskelioff, Mauro.
\newblock Monatron: An extensible monad transformer library.
\newblock In \emph{Implementation and Application of Functional Languages},
  pages 233--248. Springer, 2011.
  
\bibitem{OOHaskell}
  Kiselyov, Oleg \& L{\"a}mmel, Ralf.
  \newblock {Haskell's overlooked object system}.
  \newblock \emph{arXiv preprint cs/0509027}, 2005.
  \newblock Draft.

\bibitem{kiselyov2013extensible}
Kiselyov, Oleg \& Sabry, Amr \& Swords, Cameron.
\newblock Extensible effects: an alternative to monad transformers.
\newblock In \emph{Proceedings of the 2013 ACM SIGPLAN symposium on Haskell},
  pages 59--70. ACM, 2013.

\bibitem{loh2006open}
L{\"o}h, Andres \& Hinze, Ralf.
\newblock Open data types and open functions.
\newblock In \emph{Proceedings of the 8th ACM SIGPLAN international conference
  on Principles and practice of declarative programming}, pages 133--144. ACM,
  2006.

\bibitem{plotkin2009handlers}
Plotkin, Gordon \& Pretnar, Matija.
\newblock Handlers of algebraic effects.
\newblock In \emph{Programming Languages and Systems}, pages 80--94. Springer,
  2009.

\bibitem{schrijvers2011monads}
Schrijvers, Tom \& Oliveira, Bruno C. d.~S.
\newblock Monads, zippers and views: virtualizing the monad stack.
\newblock In \emph{ACM SIGPLAN Notices}, volume~46, pages 32--44. ACM, 2011.

\bibitem{shields2001object}
Shields, Mark \& Peyton~Jones, Simon.
\newblock Object-oriented style overloading for Haskell.
\newblock \emph{Electronic Notes in Theoretical Computer Science}, 59\penalty0
  (1):\penalty0 89--108, 2001.

\bibitem{swierstra2008data}
Swierstra, Wouter.
\newblock Data types {\`a} la carte.
\newblock \emph{Journal of functional programming}, 18\penalty0 (04):\penalty0
  423--436, 2008.

\bibitem{wadler1998expression}
Wadler, Philip.
\newblock The expression problem.
\newblock \emph{Java-genericity mailing list}, 1998.

%\bibitem{jour} Smith, T.F., Waterman, M.S.: Identification of Common Molecular
%Subsequences. J. Mol. Biol. 147, 195--197 (1981)

%\bibitem{lncschap} May, P., Ehrlich, H.C., Steinke, T.: ZIB Structure Prediction Pipeline:
%Composing a Complex Biological Workflow through Web Services. In: Nagel,
%W.E., Walter, W.V., Lehner, W. (eds.) Euro-Par 2006. LNCS, vol. 4128,
%pp. 1148--1158. Springer, Heidelberg (2006)

%\bibitem{book} Foster, I., Kesselman, C.: The Grid: Blueprint for a New Computing
%Infrastructure. Morgan Kaufmann, San Francisco (1999)

%\bibitem{proceeding1} Czajkowski, K., Fitzgerald, S., Foster, I., Kesselman, C.: Grid
%Information Services for Distributed Resource Sharing. In: 10th IEEE
%International Symposium on High Performance Distributed Computing, pp.
%181--184. IEEE Press, New York (2001)

%\bibitem{proceeding2} Foster, I., Kesselman, C., Nick, J., Tuecke, S.: The Physiology of the
%Grid: an Open Grid Services Architecture for Distributed Systems
%Integration. Technical report, Global Grid Forum (2002)

%\bibitem{url} National Center for Biotechnology Information, \url{http://www.ncbi.nlm.nih.gov}

\end{thebibliography}
\end{document}
