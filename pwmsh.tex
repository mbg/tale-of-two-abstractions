
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage{xcolor}
\newcommand{\todo}[1]{[{\color{blue}#1}]}

\usepackage{url}
\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Object-Oriented Programming with\\Monadic State Hierarchies}

% a short form should be given in case it is too long for the running head
%\titlerunning{Programming with monadic state hierarchies}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Michael B. Gale \and Alan Mycroft}
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Computer Laboratory, University of Cambridge}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Lecture Notes in Computer Science}
\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
We present an encoding of an object system in pure Haskell supporting most conventional features of object-oriented languages, including object classes, inheritance, subtype polymorphism, and dynamic dispatch. We show a correspondence between inheritance and monad transformers by defining a state monad transformer for each class, parametrised only over the class's own state. The methods of a class are monadic computations which run on top of a stack of monad transformers, consisting of one layer for the class and each of its ancestors. The well-known limitation that functions must be ``lifted'' into the right place within a monad stack is overcome using dynamic dispatch. This encoding allows class hierarchies to be open for extension in separately-compiled modules, therefore allowing the construction of modular programs. 

\keywords{Haskell, Monad Transformers, Object-Oriented Programming}
\end{abstract}


\section{Introduction}
\label{sec:introduction}

It is folklore that dynamic dispatch can be implemented in Haskell with existential types and type classes. In the following example, a value of type $\mathit{Bird}$ is constructed by applying the $\mathit{MkBird}$ constructor to some type $a$ for which there is an instance of the $\mathit{BirdLike}$ type class:
\begin{displaymath}
\begin{array}{lcl}
\mathbf{data}~\mathit{Bird} & = & \forall a. \mathit{BirdLike}~a \Rightarrow \mathit{MkBird}~a
\end{array}
\end{displaymath}
The $\mathit{Bird}$ type effectively serves as an abstract base class. It is not possible to obtain a value of this type without some other type $a$ which implements $\mathit{BirdLike}$. Any such type can be seen as a subtype of $\mathit{Bird}$ and type-casts to the base class are possible by applying the $\mathit{MkBird}$ constructor. The type class constraint ensures that every subtype has the properties we would expect of, in this example, a bird.

This is an intriguing concept, but is often perceived as an anti-pattern \todo{cite?}. After all, why would we bother with a base class type if we can simply place a type class constraint on every function expecting bird-like arguments and avoid the $\mathit{Bird}$ type all-together?

We answer this question and show how the above concept can be elevated from a neat trick without much practical use to the foundation of an object system with a range of applications \todo{``range of''?}. Specifically, our contributions are:
\begin{itemize}
\item We build upon the technique of using existential types combined with type classes to encode a comprehensive object system in Haskell, supporting object classes, inheritance, subtype polymorphism, and dynamic dispatch \todo{adjust this list?}. In section \ref{sec:usage} we first show how objects in our encoding are used within a standard Haskell program, before describing the encoding itself in section \ref{sec:encoding}.
\item Class hierarchies in our encoding are open for extension in separately-compiled modules. We thereby improve upon \emph{e.g.} open data types and functions which require whole program compilation.
\item Monad transformers are infamous \todo{cite?} for requiring programmers to explicitly reference where in a stack of monad transformers a function should be executed. In Haskell, this is accomplished by wrapping a function in a call to $\mathit{lift}$ for every monad in the stack that should be skipped. Our system hides this boilerplate in the dynamic dispatch mechanism. 
\item In section \ref{sec:auto}, we show a simple notation for object classes, following the conventions of object-oriented languages, that can be used by a pre-processor to generate the corresponding encodings in Haskell.
\end{itemize}

\section{Using the Encoding}
\label{sec:usage}

Before diving into the mechanics of our encoding, let us consider a couple of \todo{adjust} examples in the notation which we will introduce in detail in section \ref{sec:auto}.

\begin{displaymath}
\begin{array}{l}
\mathbf{state}~\mathit{MutableListItem}~a~\mathbf{where} \\
\quad \begin{array}{lcl}
\mathbf{data}~\mathit{value} & :: & a \\
\mathbf{data}~\mathit{next}  & :: & \mathit{Maybe}~(\mathit{MutableListItem}~a)
\end{array}\\\\
\quad \begin{array}{lcl}
\mathit{insertTo} & :: & \mathit{MutableListItem}~a \to ()\\
\mathit{insertTo}~v & = & \mathbf{do} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{mn} & <: & \mathit{next} \\
\multicolumn{3}{l}{\mathbf{case}~\mathit{mn}~\mathbf{of}} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{Nothing} & \to & \mathbf{do}~(\mathit{Just}~v) >: \mathit{next} \\
(\mathit{Just}~n) & \to & \mathbf{do}~(\mathit{snd}~\$~n.\mathit{insertTo}~v) >: \mathit{next}
\end{array}}
\end{array}}
\end{array}
\end{array}
\end{displaymath}
This declaration introduces a new object class $\mathit{MutableListItem}$ with two fields, $\mathit{value}$ and $\mathit{next}$, as well as one method named $\mathit{insertTo}$. The type of this method may initially seem confusing since we would expect it to return an updated object and the $\mathbf{do}$-notation suggests a monad. This is indeed the case, but since all methods are automatically state transformers belonging to a state monad

We take $\mathit{MutableListItem}$ objects to declare a $\mathit{MutableList}$ class:
\begin{displaymath}
\begin{array}{l}
\mathbf{state}~\mathit{MutableList}~a~\mathbf{where} \\
\quad \begin{array}{lcl}
\mathbf{data}~\mathit{root}  & :: & \mathit{Maybe}~(\mathit{MutableListItem}~a)
\end{array}\\\\
\quad \begin{array}{lcl}
\mathit{insert} & :: & a \to ()\\
\mathit{insert}~v & = & \mathbf{do} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\multicolumn{3}{l}{\mathbf{let}}\\
\multicolumn{3}{l}{\quad \mathit{item} = \mathbf{new}~\mathit{MutableListItem}~v~\mathit{Nothing}} \\
\mathit{mr} & <: & \mathit{root} \\
\multicolumn{3}{l}{\mathbf{case}~\mathit{mr}~\mathbf{of}} \\
\multicolumn{3}{l}{\quad \begin{array}{lcl}
\mathit{Nothing} & \to & \mathbf{do}~(\mathit{Just}~\mathit{item}) >: \mathit{root} \\
(\mathit{Just}~r) & \to & \mathbf{do}~(\mathit{Just}~(\mathit{snd}~\$~r.\mathit{insertTo}~\mathit{item})) >: \mathit{root}
\end{array}}
\end{array}}
\end{array}
\end{array}
\end{displaymath}

\section{Encoding}
\label{sec:encoding}

\todo{The gory details}

\begin{itemize}
\item Three types per object class: data, object, and state monad
\item Different ``zipper'' arrangements depending on base/child, abstract, and final attributes
\item Type class per object class with 2 functions for each method (external vs. internal call)
\item Zipper traversal in the function definitions and construction of the monad stack
\end{itemize}

\section{Casts}
\label{sec:casts}

So far we have shown how to call methods on base class objects, but since subtyping is not just represented on type level, but also in the value representation of an object, 

\begin{itemize}
\item internal $\mathit{invoke}$ function which uses the zipper to construct a monad stack from an arbitrary focus
\end{itemize}

\section{Auto-generation}
\label{sec:auto}

\begin{itemize}
\item translation rules for notation to standard Haskell
\end{itemize}

\section{Related Work}
\label{sec:related}

\begin{itemize}
\item Haskell's hidden object system
\item open data types and open functions
\item data types a la carte
\item extensible effects, etc.
\end{itemize}

\todo{Relevant parts from my thesis proposal:}

\cite{jaskelioff2011monatron} shows a monad transformer library called \emph{Monatron} which features an improved lifting mechanism at the cost of increased implementation complexity. \cite{schrijvers2011monads} describe \emph{monad zippers} and \emph{monad views} which are used to hide and address parts of monad stacks, respectively.

The most promising solution so far has been presented in \cite{kiselyov2013extensible} where a single monad, parameterised over a set of effect handlers \cite{plotkin2009handlers} is used to effectively implement an effect system in Haskell. The order of effects is not fixed on the type-level, but is determined on the value level. This system is also more efficient than monad transformers since it is no longer necessary to call each monad's $\gg\!\!=$ function at every step. 

%\section{Effect handlers}

%Effect handlers \citep{plotkin2009handlers}, etc.

Extending Haskell with an object system is not a new idea. \cite{OOHaskell} present such an encoding, but focus on remaining true to object-oriented programming. As a result, their system is impure and requires IO references to account for mutability and aliasing. \cite{shields2001object} show how to extend Haskell to allow the encoding of object-oriented style overloading. Their goal is to allow Haskell programs to provide interfaces to libraries written in object-oriented languages, but not to write object-oriented style code in Haskell itself.

In more theoretical work, \cite{Pierce93simpletype-theoretic} present a typed $\lambda$-calculus with support for encapsulation, message passing, subtyping, and inheritance. Methods in this calculus are state transformers, but they do not form stacks of state monad transformers. Instead, methods simply use the object as state as in traditional object-oriented programming.

The expression problem \cite{wadler1998expression} is concerned with extending programs with new functionality without having to change any of the existing code. A classical example of this is wishing to extend an expression language which supports basic arithmetic expressions with new forms of expressions which add \emph{e.g.} support for exceptions.  

In object-oriented programming languages this can be accomplished using an abstract class for expressions which all forms of expressions derive from. Our system allows for similar implementations. However, other approaches exist for Haskell. \cite{loh2006open} propose an extension to Haskell which enables data types and functions to be marked as ``open'', allowing new constructors and equations to be added respectively after an initial declaration. This is accomplished by generating normal data types and functions from all open declarations within a program. Unfortunately, their proposal also requires the order in which pattern matching occurs to be changed.

\cite{swierstra2008data} shows how modular data types can be constructed without any new extensions to Haskell's type system. This approach has been used to construct \emph{e.g.} modular compilers \cite{day2012towards}, but is more complicated than open data types are. 

\section{Conclusion and Future Work}
\label{sec:conclusions}

\begin{itemize}
\item extend to other monad transformers / effects to avoid the ``lifting''
\item exploit additional structure for more efficient compilation 
\end{itemize}

\subsubsection*{Acknowledgments.} Content

\begin{thebibliography}{4}

%\bibitem{jour} Smith, T.F., Waterman, M.S.: Identification of Common Molecular
%Subsequences. J. Mol. Biol. 147, 195--197 (1981)

%\bibitem{lncschap} May, P., Ehrlich, H.C., Steinke, T.: ZIB Structure Prediction Pipeline:
%Composing a Complex Biological Workflow through Web Services. In: Nagel,
%W.E., Walter, W.V., Lehner, W. (eds.) Euro-Par 2006. LNCS, vol. 4128,
%pp. 1148--1158. Springer, Heidelberg (2006)

%\bibitem{book} Foster, I., Kesselman, C.: The Grid: Blueprint for a New Computing
%Infrastructure. Morgan Kaufmann, San Francisco (1999)

%\bibitem{proceeding1} Czajkowski, K., Fitzgerald, S., Foster, I., Kesselman, C.: Grid
%Information Services for Distributed Resource Sharing. In: 10th IEEE
%International Symposium on High Performance Distributed Computing, pp.
%181--184. IEEE Press, New York (2001)

%\bibitem{proceeding2} Foster, I., Kesselman, C., Nick, J., Tuecke, S.: The Physiology of the
%Grid: an Open Grid Services Architecture for Distributed Systems
%Integration. Technical report, Global Grid Forum (2002)

%\bibitem{url} National Center for Biotechnology Information, \url{http://www.ncbi.nlm.nih.gov}

\end{thebibliography}
\end{document}
