\section{Conclusions and future work}
\label{sec:conclusions}

We have shown how several concepts in object-oriented programming related to concepts in functional programming. Most notably, we have established a link between monad transformers and inheritance. In order to take advantage of this connection, we have encoded an object system based on state monad transformers in pure Haskell. Our encoding also has a notation of coercive subtyping which allows for the construction of modular data types in Haskell. Additionally, we have described a process for translating to our encoding from a simple object-oriented language. This process is implemented in a Haskell library, enabling programmers to use object classes in their Haskell programs without having to resort to a different language or impurity. Almost all of the types in our system can be inferred, with the only exceptions of method types and the results of $\mathit{new}$.

The type classes which support the inheritance mechanism hide calls to the $\mathit{lift}$ function of monad transformers from the programmer, while also allowing more fine-grained control through the opportunity for method overriding. Each layer of our monad stack is mapped to a corresponding object class. We believe that this is a powerful representation of monad transformers which we plan to explore further in future work to allow for non-state classes.

A major limitation of our encoding compared to popular object-oriented languages is the lack of aliasing. While we do not believe that aliasing is an essential feature of an object system, it is often considered a key feature of object-oriented programming. Unfortunately, it requires references to an object to be shareable so that an update through one can be observed through the others -- a side effect. In impure languages, this is accomplished by storing all objects in a global heap, but this makes reasoning about such programs difficult. A good compromise may be the introduction of localised heaps which are shared between all functions which possess an alias to the same object. This may be accomplished with the help of the $\mathit{ST}$ monad \cite{launchbury1995state} which provides local, mutable state in Haskell. Such a system would not only improve our encoding, but matches similar efforts in object-oriented languages to better encapsulate objects -- see, for example, the essay by Hogg\cite{hogg1992geneva} on controlling object aliasing or ownership types\cite{clarke1998ownership}.

Outside of the context of Haskell, it may also be interesting to design a language with an object system for effect in mind. This could lead to a simpler representation of objects through corresponding language support, potentially leading to greater computational efficiency. However, we have not yet investigated how our encoding performs. 

