\section{Conclusions and future work}
\label{sec:conclusions}

We have shown how to encode an object system in pure Haskell, built on top of monad transformers. Additionally, we have described a process for translating to our encoding from an object-oriented language. This process is implemented in a Haskell library enabling programmers to use object classes in their Haskell programs without having to resort to a different language or impurity. Our system allows programmers to write modular programs in a purely functional language in a familiar style. 

The dynamic dispatch mechanism hides calls to the $\mathit{lift}$ function of monad transformers from the programmer, while also allowing more fine-grained control. Each layer of our monad stack is mapped to a corresponding class. Overriding a method in one class can be used to intercept calls from sub-classes. We believe that this is a powerful representation of monad transformers which, if generalised to monads other than the state monad, would allow us to reduce the amount of boilerplate which is currently required.

Our library currently provides a minimal set of combinators and has some limitations which we would like to address, such as being able to combine multiple selectors. We would also like to be able to infer from the context a combinator gets called in whether the internal or external version of a method should be invoked.

A major limitation of our encoding is the lack of aliasing. While aliasing is often considered a key feature of object-oriented programming, it requires references to an object to be shareable so that an update through one can be observed through the others -- a side effect. In impure languages, this is accomplished by storing all objects in a global heap, but this makes reasoning about such programs difficult. A good compromise may be the introduction of localised heaps which are shared between all functions which possess an alias to the same object. This may be accomplished with the help of the $\mathit{ST}$ monad \cite{launchbury1995state} which provides local, mutable state in Haskell. Such a system would not only improve our encoding, but matches similar efforts in object-oriented languages to better encapsulate objects -- see, for example, the essay by \citet{hogg1992geneva} on controlling object aliasing or ownership types \cite{clarke1998ownership}.

Our encoding is also inefficient when compared to object-oriented languages because of our complex value representation of objects. However, since we share the same high-level structures, an interesting avenue for future work may lie in the efficient compilation of our encoding, especially in the context of a language such as Haskell. 

