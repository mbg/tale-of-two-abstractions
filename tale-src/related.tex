

\section{Related work}
\label{sec:related}

\textbf{COPIED FROM OLD VERSION}

Extending Haskell with an object system is not a new idea. Previous work by \citet{kiselyov2005haskell} evaluated various approaches to constructing object systems within Haskell and emphasised encoding information about object classes in the type system. Their library supports many of the principal features of object-oriented languages, but uses IO references to accomplish this. There has also been work to allow Haskell to interact with object-oriented languages more easily, such as an extension allowing the encoding of object-oriented style overloading \cite{shields2001object}. They also use type classes to establish a subtyping relation. However, this does not allow object-oriented style code to be written in Haskell itself.

The popular \texttt{lens} library by Edward Kmett\footnote{\url{https://hackage.haskell.org/package/lens}} provides types and combinators for the traversal and manipulation of data structures. A $\mathit{Lens}$ combines a getter and setter for a field. Lenses can be composed to traverse nested data structures. This is similar to what the combinators in our library aim to achieve. We are very interested in combining lenses with our encoding of objects so that the vast number of combinators in the lens library can be used on top of our system. 

While most programming languages with object-oriented features are impure, theoretical backing for our system comes from formalisations of pure object calculi based on the $\lambda$-calculus such as in \citet{pierce1994simple}. Methods in this system are state transformers like in ours, taking objects as arguments and returning updated objects. We believe that this approach is more flexible because it places more control over the object system in the hands of the programmer.

%In more theoretical work, \cite{Pierce93simpletype-theoretic} present A typed $\lambda$-calculus with support for encapsulation, message passing, subtyping, and inheritance is presented by. Methods in this calculus are state transformers, but they do not form stacks of state monad transformers. Instead, methods simply use the object as state as in traditional object-oriented programming.

The expression problem \cite{wadler1998expression} is concerned with extending programs with new functionality without having to change any existing code. A classical example of this is wishing to extend a programming language with new features without having to change any existing code. Our example in Section \ref{sec:usage} demonstrates how this can partially be approached in our system. Other approaches exist for Haskell as well. Open data types and functions \cite{loh2006open} is a proposed extension for Haskell which enables data types and functions to be marked as ``open''. This keyword allows new constructors and function equations to be added after an initial declaration. This is accomplished by generating normal data types and functions from all open declarations within a program. This approach has the advantage that it does not introduce any new concepts to the language. However, it does require whole-program compilation and changes to the order in which pattern matching occurs.

Modular data types can be constructed in Haskell without any new extensions to the type system using the data types \`a la carte technique \cite{swierstra2008data}. Unlike open data types, it does not require whole-program compilation, but instead it requires a stronger grasp of the underlying techniques. This approach has been used to construct \emph{e.g.} modular compilers in which independent language fragments can introduce effects to the overall language \cite{day2012towards}. It is not clear how easily effects can be interleaved in our system without extending the system itself.

%An alternative monad transformer library called \emph{Monatron} \cite{jaskelioff2011monatron} which features an improved lifting mechanism at the cost of increased implementation complexity improves upon the \texttt{mtl} library, but shifts the difficulty from library users to library authors. \emph{Monad zippers} and \emph{monad views} \cite{schrijvers2011monads} which are used to hide and address parts of monad stacks respectively provide another interesting approach to dealing with the complexity of monad transformers.

%One of the most promising solutions so far has been presented in \cite{kiselyov2013extensible} where a single monad, parametrised over a set of effect handlers \cite{plotkin2009handlers} is used to implement an effect system in Haskell. The order of effects is not fixed on the type-level, but is determined on the value level. This system is also more efficient than monad transformers since it only needs to find a matching handler when a given effect is required. Monad transformers, on the other hand, always execute all of their effects between computations, even if most of them are not required. 