

\section{Related work}
\label{sec:related}

Extending Haskell with an object system is not a new idea. Previous work evaluated various approaches to constructing object systems within Haskell and emphasised encoding information about object classes in the type system~\cite{kiselyov2005haskell}, which our encoding does not. Their library supports many of the principal features of object-oriented languages, but uses IO references to accomplish this while we wish to remain pure. There has also been work to allow Haskell to interact with object-oriented languages more easily, such as a language extension allowing object-oriented-style overloading in Haskell~\cite{shields2001object}. Type classes are also used to establish a subtyping relation. However, their work does not allow object-oriented style code to be written in Haskell itself.

The popular \texttt{lens} library by Edward Kmett\footnote{\url{https://hackage.haskell.org/package/lens}} and similar other libraries provide types and combinators for the traversal and manipulation of data structures. A $\mathit{Lens}$ combines a getter and setter for a field, similarly to our selectors. Lenses can be composed to traverse nested data structures.
Combining lenses with our encoding of objects (future work)
would enable the vast number of combinators in the \texttt{lens} library to be used on top of our system.

While most programming languages with object-oriented features are impure, theoretical backing for our system comes from formalisations of pure object calculi based on the $\lambda$-calculus~\citet{pierce1994simple}. Methods in this system are state transformers like in ours, taking objects as arguments and returning updated objects. We believe that the explicitness of a purely-functional object system allows for more flexibility than the implicitness of an impure system.

%In more theoretical work,~\cite{Pierce93simpletype-theoretic} present A typed $\lambda$-calculus with support for encapsulation, message passing, subtyping, and inheritance is presented by. Methods in this calculus are state transformers, but they do not form stacks of state monad transformers. Instead, methods simply use the object as state as in traditional object-oriented programming.

The expression problem is concerned with the choice between different ways in which programs may be extended with new functionality without having to change any of the existing code. A classical example of this is wishing to extend a programming language with new features without having to change any existing code. Our example in Section \ref{sec:encoding} demonstrates how this can partially be approached in our system. We have also drawn an analogy between the expression problem and the ``monad transformer problem''. 

Other approaches to modular data types exist for Haskell as well. Open data types and functions is a proposed extension for Haskell which enables data types and functions to be marked as ``open''. A data type marked with this keyword allows new constructors and function equations to be added after the initial declaration. This is accomplished by generating normal data types and functions from all open declarations within a program. While this approach has the advantage that it does not introduce any fundamentally new concepts to the language, it does require whole-program compilation and changes the order in which pattern matching occurs~\cite{loh2006open}.

Modular data types can be constructed in Haskell without any new extensions to the type system using the \emph{data types \`a la carte technique}~\cite{swierstra2008data}. Unlike open data types, it does not require whole-program compilation, but instead it requires a stronger grasp of the underlying techniques. To the authors' knowledge, there is no simple notation for the \`a la carte technique. This technique has been used to construct \emph{e.g.} modular compilers in which independent language fragments can introduce effects to the overall language~\cite{day2012towards}. It is not clear how easily effects can be interleaved in our system, since we assume a fixed ordering of effects.

%One alternative to the monad transformer library called \emph{Monatron}~\cite{jaskelioff2011monatron} which features an improved lifting mechanism at the cost of increased implementation complexity improves upon the \texttt{mtl} library, but shifts the difficulty from library users to library authors. \emph{Monad zippers} and \emph{monad views}~\cite{schrijvers2011monads} which are used to hide and address parts of monad stacks respectively provide another interesting approach to dealing with the complexity of monad transformers.

%One of the most promising solutions so far has been presented in~\cite{kiselyov2013extensible} where a single monad, parametrised over a set of effect handlers~\cite{plotkin2009handlers} is used to implement an effect system in Haskell. The order of effects is not fixed on the type-level, but is determined on the value level. This system is also more efficient than monad transformers since it only needs to find a matching handler when a given effect is required. Monad transformers, on the other hand, always execute all of their effects between computations, even if most of them are not required.
